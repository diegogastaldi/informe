\lhead{\emph{Introducción}}
\chapter{Introducción}

Este proyecto consiste en el desarrollo de una herramienta basada en análisis estático de flujo de la información para programas {\tt Android} con el fin de verificar la ausencia de filtraciones (no deseadas) de información confidencial. 
La herramienta toma como entrada un conjunto de aplicaciones destinadas al sistema operativo {\tt Android}, luego las decompila (es decir, obtiene su código en algún lenguaje específico, como puede ser Java o un lenguaje intermedio), para así, poder analizar el flujo de la información de las aplicaciones y comprobar si estas aplicaciones tiene un comportamiento malicioso o no. \par

\section{Motivación}

Este trabajo surge  a causa de la deficiencia que tienen los repositorios de aplicaciones {\tt Android}, ya que, a pesar de que brindan una manera automática, de costo mínimo, para resolver la distribución o sustitución de código para enormes cantidades de destinatarios, esta técnica también entraña graves riesgos, ya que el software de los repositorios puede comprometer la confidencialidad y/o integridad de los datos de sus numerosos destinatarios, tanto por fallas de programación, como por intenciones maliciosas. Este problema no es nuevo, ni exclusivo de {\tt Android}, por lo que la búsqueda de soluciones para este problema ha dado origen a activas líneas de investigación \cite{InformationFlow}. \par

Un ejemplo de la explotación de estas deficiencia se da cuando un usuario de un dispositivo (smartphone, tablet, etc) instala un juego para {\tt Android} que filtra toda la lista de contactos del usuario (obteniendo previamente permiso para hacerlo) a una empresa de marketing mediante el envío de los contactos a otra aplicación con los permisos necesarios para acceder a internet, llevándose a cabo una fuga de información que no fue detectada ni controlada por el sistema. \par

El problema de la integridad de la información manipulada por aplicaciones {\tt Android} es de gran importancia, dado el intenso uso de esta plataforma. Pero, es muy difícil y costoso realizar las pruebas y la depuración para garantizar la inexistencia de dicho problema. Por ello, es necesario contar con técnicas y herramientas automáticas que verifiquen estáticamente estas propiedades.\par

La aplicación de análisis estáticos inter e intraprocedural que permitan determinar el flujo de la información permitirá garantizar la confidencialidad e integridad de la información manipulada por programas {\tt Android}. La construcción de un prototipo podrá clarificar la viabilidad, eficiencia y eficacia del uso de análisis estático para la verificación de confidencialidad e integridad de la información en este tipo de aplicaciones.\par


\section{Contribución}

La herramienta obtenida como resultado de este trabajo combina y extiende las funcionalidades provistas por trabajos previos como {\tt DidFail} \cite{Didfail}, {\tt Flowdroid} \cite{Flowdroid} y {\tt Epicc} \cite{Epicc} añadiendo la posibilidad de asignar niveles de seguridad a cada uno de los métodos que obtienen información del usuario y a cada método que permite enviar dicha información a, por ejemplo, otra aplicación o internet. Esta asignación de niveles de seguridad es, nada más ni nada menos, que la definición de la política de seguridad del usuario. Los niveles de seguridad estan relacionados por un orden parcial. Dicho orden también es definido por el usuario. La extensión a las herramientas mencionadas anteriormente utiliza el orden parcial de los niveles y la política de seguridad definida por el usuario para comprobar si la información fluye de manera segura. Es decir, si la información fluye de acuerdo a la política de seguridad definida o se produce alguna una violación (pérdida no deseada de información). \par

Tanto los niveles asignados a cada método como los flujos que deben ser ignorados (excepciones) pueden ser proporcionados por el usuario de dos maneras diferentes: mediante el uso de una interfaz gráfica o mediante archivos de configuración. \par

También, se brinda un archivo de configuración para el establecimiento de la jerarquía que relaciona los niveles de seguridad (es un retículo de niveles de seguridad). Ésta debe cumplir con ciertos requisitos que se mencionarán a lo largo del informe.\par

En cuanto a los resultados, se informa del flujo que produce la violación, en caso que exista, o de la ausencia de estos en caso contrario. Dichos resultados pueden verse de la misma manera que las entradas al sistema, es decir, de manera gráfica o guardado en un archivo.\par

Además, el usuario tiene la posibilidad de no proveer niveles a los métodos que crea conveniente, permitiendo a la herramienta el cálculo de un nivel adecuado para evitar problemas de seguridad (en caso de ser posible). Estos niveles calculados automáticamente se incluyen a los resultados del análisis.\par

Por otro lado, se realizaron modificaciones a {\tt Didfail} \cite{Didfail} para realizar los análisis individuales de las aplicaciones de manera concurrente, y se generó un alternativa para los casos en que las aplicaciones ya fueron analizadas individualmente y solo se pretende verificar nuevas asignaciones de niveles de seguridad, ya que la primer parte del análisis es la más costosa en cuanto a tiempos y recursos que utiliza {\tt DidFail}.\par

La herramienta desarrollada se encuentra disponible en 

{\it https://github.com/diegogastaldi/security\_android.git}. 

\section{Estructura del Informe}

El resto del informe está organizado como se describe a continuación. 
El capítulo 2 provee una introducción a los conceptos importantes para este trabajo, como es el análisis estático, {\tt Android} (conceptos relacionados con el tema) y un resumen de las herramientas utilizadas. Además, se presenta un ejemplo motivador. 
El capítulo 3, describe en detalle el aporte provisto por este trabajo. 
En el capítulo 4 se describe la implementación de la herramienta desarrollada. 
En cuanto al capitulo 5, contiene un ejemplo del uso del analizador juntos con los resultados obtenidos. 
Se discuten las limitaciones del análisis en el capítulo 6, y las conclusiones a las que se llegaron en el capítulo 7. \par
