\lhead{\emph{Conocimientos Previos}}
\graphicspath{{Imagenes/}} 

\chapter{Conocimientos Previos}

\section{Análisis Estático}

El análisis estático es un método de análisis en el cual el código fuente es analizado sin ser ejecutado. Como contrapunto, el análisis dinámico involucra el estudio  del comportamiento de las aplicaciones a través de la ejecución de las mismas en un ambiente determinado (los dispositivos android en nuestro caso).\par
El análisis estático permite examinar todas las posibles ejecuciones de un programa. Esto es especialmente valioso en el análisis de la seguridad, ya que los ataques suelen explotar aplicaciones de maneras imprevistas y no probados. Sin embargo, predecir el comportamiento del programa sin ejecutar no es un problema trivial. Al reducir al problema de la parada (halt), es posible demostrar que la búsqueda de todas las maneras posibles de ejecutar cualquier programa no trivial arbitrario es un problema indecidible. Sin embargo, el análisis estático puede proporcionar resultados útiles mediante la aproximación de algunas facetas de la ejecución real de un programa \cite{AbsInt}.\par
Una de las técnicas de análisis estático lleva a cabo el análisis del flujo de datos (data flow). El taint analysis es un tipo especial de análisis de flujo de datos que realiza el seguimiento de datos a lo largo del camino de la ejecución del programa. En esta técnica, los datos sensibles son marcados con una mancha en la fuente u origen, y se propaga a través de todas las rutas de ejecución del programa. La presencia de este mancha en los sink o destinos predefinidos se utiliza para establecer un flujo entre la fuente y el sink. Este flujo puede ser utilizado para detectar las fugas de datos sensibles desde la fuente a diferentes destinos. Donde, si además, se agregan niveles tanto a los source (fuentes) como a los sinks, se pueden detectar si información importante o privada puede estar llegando a lugares públicos o no deseados.\par

\section{Information Flow}

La protección de la confidencialidad de la información manipulada por los sistemas de computación no es un problema de los últimos años, sino por el contrario, es un problema de larga data siendo cada vez más importante. Las prácticas de seguridad estándares previas al surgimiento de estudios sobre information-flow \cite{InformationFlow} no ofrecían garantías sustanciales de que el comportamiento de extremo a extremo de un sistema informático satisfacía las políticas de seguridad importantes como la confidencialidad. Una política de confidencialidad de extremo a extremo afirma que los datos de entrada considerados secretos no pueden deducirse por un atacante a través de observaciones sobre salida del sistema.\par
Los mecanismos de seguridad convencionales, tales como el control de acceso y cifrado no se refieren directamente a la aplicación de las políticas de flujo de información. Analizar las características de confidencialidad de un sistema informático es difícil, ya que estos puede incluir errores de implementación y diseño y, sumado a ésto, como los sistemas informáticos modernos comúnmente incorporan hosts o código que no son de confianza, posiblemente maliciosos, hace que la garantía de confidencialidad sea aún más difícil. \par 
Una forma estándar para proteger los datos confidenciales es el control de acceso, el cual requiere de algún privilegio para poder acceder a los archivos u objetos que contienen los datos confidenciales. El problema aquí es que las verificaciones de control de acceso imponen restricciones a la divulgación de información, pero no de su propagación. Una vez que la información es liberado de su contenedor, el programa que accede a ella puede, por error o malicia, inadecuadamente transmitir la información en alguna forma. No es realista suponer que todos los programas en un sistema de computación grande son dignos de confianza. De igual manera, los mecanismos de seguridad tales como la verificación de firmas y escaneo de antivirus tampoco garantizan la conservación de la confidencialidad. \par
Para asegurar que la información se utiliza de acuerdo con las políticas de confidencialidad pertinentes, es necesario analizar cómo fluye la información dentro del programa. La creencia de que un sistema es seguro con respecto a la confidencialidad debe surgir de un análisis riguroso que demuestre que el sistema en su conjunto hace cumplir las políticas de confidencialidad de sus usuarios. Este análisis debe demostrar que la información controlada por una política de confidencialidad no puede fluir a un lugar donde se viola esa política. La Figura 1 muestra un ejemplo básico indicando un flujo permitido y uno que no lo es (que viola las políticas de seguridad). Las políticas de confidencialidad que deseamos cumplir son, por lo tanto, las políticas de flujo de información y los mecanismos que las hacen cumplir son los controles de flujo de información. \par
Lo anterior mencionado fué la base para el surgimiento de un nuevo enfoque en el que se utilizan técnicas de lenguajes de programación para especificar y hacer cumplir las políticas de flujo de información.\par

\begin{center}
 \includegraphics[scale=0.5]{Figura1} \par
 Figura 1: Flujos permitidos y no permitidos.
 \end{center}

El análisis de confidencialidad e integridad para lenguajes de bajo nivel (assembly, bytecode) \cite{JavaBytecodeVerif, InformFlowForLowLevel, VerConfPolForMobCod, TypAssLangConf, PreStatAna} en la actualidad tiene un menor desarrollo que el alcanzado para lenguajes de alto nivel (Java, C). Esto se debe principalmente a la dificultad de razonar con programas no estructurados. Existen trabajos basados en sistemas de tipos que incluyen un subconjunto bastante extenso de Java bytecode \cite{SecTypePresComp, InformFlowForLowLevel, VerConfPolForMobCod, InformFlowByteode}. \par
Numerosos trabajos se direccionan en extender el análisis para que soporte desclasificación de información \cite{DimensPrincDeclass}. Entre estos podemos nombrar \textit{Intransitive noninterference} \cite{PreStatAna}, \textit{decentralized label model} \cite{AndrTaintFlow}, \textit{relaxing noninterference} \cite{DinDep, InfFloMon} y \textit{robust declassification} \cite{EnfRobDeclQuaRob}. En el caso específico del último mencionado, no es un tema cerrado \cite{ChallInformFloSec} ya que no hay trabajos específicos en cuanto a desclasificación para lenguajes de bajo nivel, como bytecode: para verificar que programas en Bytecode satisfacen robust declassification es necesario poder verificar que los ataques (código no confiable insertado en determinados puntos del programa) cumple con ciertos requisitos. Por lo tanto, si se quiere contar con una herramienta para verificar la seguridad de los programas que pueda ser utilizada en la práctica es necesario poder verificar que los ataques no violan los requisitos. Actualmente no existen análisis ni herramientas que garanticen robust declassification para aplicaciones Android.\par
Los resultados preliminares sobre técnicas de information-flow para Bytecode \cite{InformFlowByteode, VarObjFiel} y Robust Declassification para Bytecode \cite{EnfRobDeclQuaRob, TypInformFlow}, si bien contribuyen al conocimiento de IFA, no son técnicas enfocadas a aplicaciones Android. Dado el estado del arte en el área de information-flow y desclasificación es necesario avanzar en la definición de análisis para aplicaciones Android.\par

\subsection{Niveles de Seguridad}

El punto de partida en el análisis del flujo de información es la clasificación de las variables del programa en diferentes niveles de seguridad. La forma más básica de clasificar las variables puede ser L (low) a las variables de baja seguridad, con información pública; y H (hight) a las de alta seguridad, con información privada. El objetivo es prevenir que la información privada se filtre de manera incorrecta, es decir, evitar que la información en las variables con nivel H pueda ser asignada a las variables con nivel L. \par
En términos más generales, se requiere un retículo de niveles de seguridad para asegurar que la información fluya solamente de niveles menores a niveles mayores o iguales. Por ejemplo, si L $\le$ H, entonces se permitirían los flujos de L a L, de H a H, y de L a H, y no estaría permitido flujos de H a L: claramente es ilegal un flujo explícito donde se le a una variable pública el contenido de una privada, pero por el contrario, asignar información pública en variables privada es perfectamente legal. Otro caso, que puede ser considerado peligroso cuando, es cuando de acuerdo a condiciones que involucren información privada se realice una determinada acción, como muestra el ejemplo a continuación: \par
\begin{description}
\item[
if ((secreto\% 2) == 0)  fuga = 0;   else   fuga = 1; 
]
\end{description}
Esto copia el último bit de la variable privada ``secreto" hasta la variable pública ``fugas". \par
Otro caso interesante en el uso de niveles de seguridad es la integridad en lugar de confidencialidad. Si se ven algunas variables que contiene información posiblemente contaminada, entonces es posible que se desee evitar que la información fluya desde éstas a variables no contaminados. Se puede modelar esto utilizando un retículo con sus elementos denominados, por ejemplo, Untainted  $\le$  Tainted. \par

\subsection{Sinks y Sources}
Los sources y sinks son componentes muy importantes en los flujos de información, siendo estos los recursos mediante los cuales las aplicaciones leen u obtienen sus datos (source), para luego tratarlos según sus objetivos y concluir con el envío de estos a otros recursos denominados sink. Estos recursos son externos a las aplicaciones. \par
Dichos componentes generan dependencias que van desde determinados source a determinados sinks, por lo que al asignarle niveles de seguridad a ambos (véase sección 2.2.1) permitiría controlar o conocer los casos en los que se producen flujos ilegales de información. \par
Ejemplos de sources pueden ser el identificador, los contactos, las fotos y la ubicación de los dispositivos mobiles; y por otro lado, ejemplos de sinks incluyen internet, mensaje de texto y archivos. \par

\section{Android}

El sistema operativo Android domina el mercado de dispositivos móviles, pero las aplicaciones desarrolladas para Android se han enfrentado a algunos problemas de seguridad de gran impacto. Entre estos problemas, ah tomado  gran relevancia las vulnerabilidades que provocan fugas de datos sensibles.\par
Todos los sistemas operativos modernos, incluido Android, utilizan algún mecanismo de control de acceso para proteger los datos de posibles lecturas o modificaciones por usuarios no autorizados. Sin embargo, controlar el acceso es una medida insuficiente para supervisar la propagación de la información después que la misma ha sido accedida por una aplicación. Similarmente, la criptografía ofrece una fuerte garantía de preservar la confidencialidad pero el costo de realizar computaciones triviales con datos encriptados es muy costoso. Ninguno de estos dos enfoques provee una solución completa para proteger la confidencialidad e integridad.\par
Un enfoque complementario consiste en analizar y regular el flujo de la información en el sistema para prevenir que se filtre datos privados a lugares no autorizados.\par
En las aplicaciones Android surge un nuevo aspecto a analizar para garantizar la confidencialidad e integridad de los datos: el mecanismo de comunicación entre aplicaciones. En el middleware de Android, los intents (mensajes entre aplicaciones) son el principal medio de comunicación entre aplicaciones.\par
Un intent puede incluir un destinatario, una acción y, posiblemente, otros datos. Si ningún destinatario es designado en un intent (denominado intent implícito), entonces Android trata de determinar un receptor adecuado, los cuales son las aplicaciones que declaran en su archivo de configuración (manifiest) que pueden realizar la acción especificada por el intent. Si hay varias aplicaciones en estas condiciones, Android solicita al usuario que seleccione la aplicación que atienda el requerimiento. Cabe destacar que el usuario puede designar la aplicación por defecto que procese todos los intents similares. Sin embargo, una aplicación maliciosa puede engañar al usuario mediante el uso de un nombre confuso. También, un usuario poco atento podría no dar mucha importancia a la elección. Cuando una aplicación maliciosa recibe un mensaje que fue pensado para otra aplicación, el usuario está ante un ataque de secuestro (de intent).
Además de la comunicación entre aplicaciones, los intents también se utilizan para la comunicación intra-aplicación entre los diferentes componentes de una sola aplicación. El uso de intents implícitos para la comunicación intra-aplicación ha demostrado ser un error común en el desarrollo de aplicaciones de Android. Un componente que utiliza un intent implícito para comunicarse con otro componente en la misma aplicación podría ser vulnerable a que otra aplicación intercepte su mensaje. Esto permite a aplicaciones maliciosas secuestrar o espiar en aplicaciones que tienen acceso a información o recursos sensibles.\par

\subsection{Introducción a la plataforma Android}
Android es un pila de software de código abierto creado para una amplia gama de dispositivos, el cual está compuesto por cinco componentes principales:
\begin{description}
\item[Kernel de Linux:] Provee acceso al hardward.
\item[Código nativo de userspace:] Incluyen servicios y bibliotecas de sistemas que se comunican con servicios y drivers de bajo nivel.
\item[Bibliotecas y servicios escritos en Java].
\item[Maquina virtual Dalvik / ART:] Provee una capa de abstracción eficiente al sistema operativo.
\item[Aplicaciones Android]
\end{description}

\begin{center}
\includegraphics[scale=0.75]{Figura2}\par
 Figura 2: Android Stack.
\end{center}

Android \cite{IntAnd} trabaja en Linux, donde cada aplicación utiliza un proceso propio. Aquí los dispositivos tienen un único foco de ejecución principal, que es la aplicación que está visible en la pantalla, pero puede tener varias aplicaciones en un segundo plano, cada una con su propia pila de tareas. \par
La pila de tareas es la secuencia de ejecución de procesos en Android. Ésta está compuesta de actividades que se van apilando según son invocadas, y solo pueden terminar cuando las tareas que tiene encima ya lo hicieron, o cuando el sistema las destruye porque necesita memoria, por lo que tienen que estar preparadas para terminar en cualquier momento. El sistema siempre eliminará la actividad que lleve más tiempo parada. En caso de que se necesitara mucha memoria, si la aplicación no está en el foco, puede ser eliminada por completo a excepción de su actividad principal. \par 
Una de las características principales del diseño en Android es la reutilización de componentes entre las aplicaciones, es decir, dos aplicaciones diferentes pueden utilizar una misma componente, aunque éste esté en otra aplicación, para así evitar la repetición innecesaria de código y su consiguiente ocupación de espacio. \par
Los componentes de una aplicación son los elementos básicos con los que se construyen. Si bien hay cuatro tipos de éstos, las aplicaciones están compuestas principalmente de actividades: habrá tantas actividades como ventanas distintas tenga la aplicación. Sin embargo, por si solos, los componentes no pueden hacer funcionar una aplicación ya que es necesario que estén comunicados. Dicha comunicación es llevada a cabo a través de ``intents". \par 
Los \textit{intents} deben declararse en el archivo llamado \textit{AndroidManifest.xml}. \par
Los cuatro componentes antes mencionados son:
\begin{description}
\item[Actividades:] Una actividad (o Activity) es la componente principal encargada de mostrar al usuario la interfaz gráfica. Se define una actividad por cada interfaz del proyecto. Las actividades tienen un ciclo de vida, es decir, pasan por diferentes estados desde que se inician hasta que se destruyen: \textit{activo} cuando la actividad está en ejecución; \textit{pausado} cuando aún se está ejecutando y es visible, pero no es la tarea principal; y \textit{parado} cuando la actividad está detenida, no es visible al usuario y el sistema puede liberar su memoria.
\item[Servicio:] Los servicios (o service) son tareas no visibles que se ejecutan siempre por ``debajo'', incluso cuando la actividad asociada no se encuentra en primer plano. Tiene un hilo propio (aunque no pueden iniciar su ejecución solos), lo que permite llevar a cabo cualquier tarea, por más pesada que ésta sea.
\item[Receptores de Mensajes de Distribución:] También llamados ``broadcast receiver'', son los encargados de reaccionar ante los eventos ocurridos en el dispositivo, ya sean generados por el sistema o por una aplicación externa.
No tienen interfaz, pero pueden lanzar una ``activity'' a través de un evento.
\item[Proveedores de contenidos:] O ``content provider'', se encargan de que la aplicación pueda acceder a la información que necesita, siempre que se haya declarado el correspondiente ``provider''
en el AndroidManifest.
\item[Intents:] Los intents son el medio de activación de los componentes (excepto los content provider). Contiene los datos que describen la operación que desarrollará el componente a quien va dirigido. 
Pueden ser explícitos o implícitos (no especifican el componente al que va destinado).
\item[Intent-filters:] Utilizados únicamente por los intents implícitos. Los intent-filters definen (y delimitan) los tipos de intent puede lanzar una actividad y los que puede recibir un broadcast. Por ejemplo, para un intent que no especifica a que actividad va dirigido, se consulta el intent filter de una de ellas, y si lo satisface, el intent lanzará esa actividad. Se definen en el AndroidManifest con la etiqueta $<$ intent-filter $>$ . La información que pasan los intents debe estar contenida en la definición del intent filter para que el componente pueda ser activado (o pueda recibirlo en el caso del broadcast). Esta información se compone de tres campos: Action, Data y Category. \par
El campo Action es una cadena de caracteres que contiene la información del tipo de acción que se llevará a cabo. Las acciones pueden ser dadas por la clase Intent, por una API de Android o definidas por el diseñador. \par
El campo Data contiene la información del identificador (URI) del dato que se asocia a la acción y del tipo de ese dato. Es importante la coherencia ya que si la acción requiere un dato de tipo texto, un intent con un dato de tipo imagen no podría ser lanzado.\par
Por último, el campo Category es una cadena de caracteres que contiene información adicional sobre el tipo de componente al que va dirigido el intent.
\item[AndroidManifest:]  este fichero es un documento ``xml'' en el que se declaran los elementos de la aplicación, así como sus restricciones, permisos, procesos, acceso a datos e interacciones con elementos de otras aplicaciones. Cada elemento se declara con una etiqueta única. No debe confundirse este documento con el ``xml'' asociado a cada actividad. Los elementos gráficos y distribución de la pantalla serán definidos para cada actividad dentro de su ``xml'', pero no en el AndroidManifest. 
\end{description}

Cada aplicación es comprimida en un paquete APK, lo que permite su distribución e instalación. Estos paquetes contienen una colección de archivos, recursos, permisos, entre otras cosas, como muestra la siguiente figura. \par 

\begin{center}
\includegraphics[scale=0.5]{Figura3} \par
Figura 3: Estructura de paquete Apk de Android.
\end{center}

\subsection{Modelo de seguridad de Android}
Android utiliza dos métodos complementarios de permisos:
\begin{description}
\item[Bajo nivel:] Permisos de usuarios y grupos de Linux, conocidos como sandbox de Android. Estos permisos generan restricciones entre usuarios evitando que interactuen directamente entre sí o que un usuario acceda a los archivos de otros. Desde el punto de vista de las aplicaciones, en la mayoría de los casos cada una de ellas pertenecen a usuarios de linux diferentes.
\item[Alto nivel:] Permisos que las aplicaciones requieren que se les proporcionen para poder efectuar acciones específicas, lo cual regula el acceso de las aplicaciones a los recursos de hardware.
\end{description}

\subsection{Android y Malware}

Malware \cite{PPTSegAndroid} es el nombre genérico que se le da al software cuyo propósito resulta en causar un perjuicio al usuario (robo de información, falta de disponibilidad en los equipos de la información, gastos no autorizados). Existen diferentes tipos de Malware como virus, troyanos y gusanos.\par
En el caso del sistema operativo Android, este tipo de software logra sus propósitos de diferentes puntos:
\begin{description}
\item[Vulnerabilidad del kernel de Linux:] Sin bien son relativamente escasas y pueden hacerse obsoletas con una actualización (raramente se producen) son un punto a tener en cuenta.
\item[Abuso de confianza:] Cuando la aplicación solicita los permisos para realizar el perjuicio al usuario y éste últimos se los proporciona.
\item[Restricciones por compromiso de diseño:] Las tarjetas SD son ejemplo de éstos dado que tienen formato FAT y no implementan permisos.
\item[Aplicaciones vulnerables:] Ciertas aplicaciones con permisos necesarios para realizar sus funciones puede ser utilizadas por Malware a través de sus vulnerabilidades.
\end{description}
Como defensa ante el Malware se pueden utilizar tanto el análisis estático, como el análisis dinámico como se describió antes en este informe.

\section{Ejemplo Motivador}

La comunicación entre las aplicaciones es muy común y necesario para cumplir con sus objetivos. Esta comunicación la llevan a cabo principalmente mediante el uso de intents. Un ejemplo de ello es una foto, la cual puede fluir a través de diferentes aplicaciones: es sacada por la cámara y almacenada, luego es editada por alguna aplicación de edición para posteriormente ser compartida a través de alguna red social.\par

\begin{center}
 \includegraphics[scale=0.75]{Figura4} \par
 Figura 4: Ejemplo de comunicación entre aplicaciones.
 \end{center}
En la siguiente imagen se muestra un ejemplo donde información sensible puede fluir desde un source a un sink, y en su ``viaje", pasar por múltiples aplicaciones que pueden ver y modificar su información: \par

\begin{center}
 \includegraphics[scale=0.75]{Figura5} \par
 Figura 5: Ejemplo de flujo de información desde un source a un sink.
 \end{center}
 
Aquí la aplicación \textit{SendSms} obtiene \textit{Device Id} (Figura 6: (1)), lo guarda en un intent (Figura 6: (2)) y luego lo envía mediante el método \textit{startActivityForResult} (Figura 6: (3)) para iniciar una nueva actividad. Dicho intent es implícito, es decir, no tiene un destinatario preestablecido, por lo que el sistema operativo se encarga de comprobar que aplicaciones pueden manejarlo (mediante la comprobación de sus archivos manifest). En este ejemplo, la aplicación elegida fue \textit{Echoer.apk} debido que su Manifest cumplía con los requisitos (Figura 10: (4)). Ésta aplicación recibe el intent, lo guarda en un campo de la clase \textit{MainActivity} (Figura 8: (5)), y luego de que se oprima el botón \textit{button1}, la información que tenia el intent es enviada de vuelta a la aplicación \textit{SendSms} (Figura 9: (6)), para que este último envié el mensaje (Figura 7: (7)). \par
En el escenario descripto, el source (\textit{deviceId}), es información privada del dispositivo, puede llegar a dos sinks diferentes: uno de ellos es el Sms saliente y el otro sink es el \textit{Log}, y de acuerdo a los niveles que se le asignen a estos últimos, los flujos puede o no producir una violación de seguridad. \par
Las figura Figura 8 (5) y Figura 9 (6) muestran como fluye la información al \textit{Log} escribiendo el contenido del intent recibido.

\par
\begin{center}
 \includegraphics[scale=0.8]{Figura6} \par
 Figura 6: SendSMS.button1listener.java
 \end{center}
\par
\begin{center}
 \includegraphics[scale=0.8]{Figura7} \par
 Figura 7: SendSMS.MainActivity.java
 \end{center}
\par
\begin{center}
 \includegraphics[scale=0.8]{Figura8} \par
 Figura 8: Echoer.MainActivity.java
 \end{center}
\par
\begin{center}
 \includegraphics[scale=0.8]{Figura9} \par
 Figura 9: Echoer.button1listener.java
 \end{center}
\par
\begin{center}
 \includegraphics[scale=0.8]{Figura10} \par
 Figura 10: AndroidManifest.xml in Echoer.apk
 \end{center}
 
En este ejemplo se representa lo que sucede en muchas aplicaciones ya sea por mala intención o por descuidos: la aplicación \textit{SendSms} quiere comunicarse con otro componente de sí misma, enviarle información para que éste lo trate según corresponda, para lo cual manda un intent con dicha información. A continuación, Echoer recibe el intent, filtra la información, y luego envía otro intent para que la aplicación inicial siga con su normal funcionamiento. Aquí \textit{SendSms} no sabe que su información fue vista y tratada por otra aplicación. Este flujo es detectado por Didfail.\par

\section{Herramientas de análisis estático}

La herramienta detallada en este informe se construyó sobre Didfail, la cual a su vez utiliza Flowdroid y Epicc. \par

\subsection{Flowdroid}

Flowdroid \cite{Flowdroid} es una herramienta de análisis estático para aplicaciones Android, de código abierto. La cual reduce el programa a un simple gráfico que modela el ciclo de vida de las aplicaciones de Android. \par
Analizar dichas aplicaciones es mas complicado que analizar un programa en java  porque estos corren sin el framework de Android, tienen un simple punto de entrada (el método main). En cambio, las aplicaciones Android, pueden tener multiples puntos de entradas, llamados implícitamente por el framework. Flowdroid resuelve este problema creando un método llamado dummymain(), el cual emula el ciclo de vida de las aplicaciones incluyendo todas las llamadas implícitas que pueden ocurrir.\par
Flowdorid puede detectar precisamente solo flujos de datos intraprocedurales, ya que los interprocedurales incluyen intents, service, entre otros.\par

\subsection{Epicc}

Epicc analiza la comunicación entre componentes de manera precisa y efectiva, por lo que se podría decir que es un complemento a lo realizado por Flowdroid. \par
Epicc identifica propiedades (tales como action, category and data MIME type) de los intents que pueden ser enviados y recibidos por los diferentes componentes.

\subsection{Didfail}

DidFail (Droid Intent Data Flow Analysis for Information Leakage) \cite{Didfail} usa el análisis estático para detectar potenciales fugas de información sensible entre un conjunto de aplicaciones Android. DidFail combina FlowDroid y Epicc para realizar un seguimiento de los flujos de datos tanto entre componentes como dentro de cada componente de un conjunto de aplicaciones. DidFail tiene dos fases en el análisis:
\begin{itemize}
\item Dado un conjunto de aplicaciones, primero determina el flujo de datos individualmente por cada una, y las condiciones en las que estos son posibles.
\item Luego, basándose en los resultados de la primer fase, enumera los flujos de datos potencialmente peligrosos habilitados por las aplicaciones en su conjunto.
\end{itemize}

En los capítulos siguientes se presenta como a partir de la salida que proporciona Didfail, y mediante modificaciones en dicha herramienta, se le dan niveles a los métodos involucrados en los flujos, se chequean si se produce violaciones de seguridad de acuerdo al orden establecido entre los niveles, ignorando aquellos métodos que son considerados excepciones, y las opciones para introducir dicha información.\par
